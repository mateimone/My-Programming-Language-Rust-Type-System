-- A program is defined as a (possibly empty) list of statements separated by semicolons,
-- followed by an expression which will be evaluated to produce an output.

entrypoints Program;

Program. Program ::= [Stmt] "return " Exp ;

--This is the syntax from BNFC to define a list of statements
[].    [Stmt] ::= ;
(:).   [Stmt] ::= Stmt [Stmt] ;

[].    [Exp]  ::= ;
(:).   [Exp]  ::= Exp [Exp] ;

ArgImm.   Arg  ::= Ident ":" Type ;
ArgMut.   Arg  ::= "mut" Ident ":" Type ;
separator Arg "," ;
separator Exp7 "," ;
IndexList. IndexList ::= "[" Exp "]" ;
[]. [IndexList] ::= ;
(:). [IndexList] ::= IndexList [IndexList] ;

-- TYPES --------------------------------------------------------------

TInt.     Type1 ::= "int";
TBool.    Type1 ::= "bool";
TUnit.    Type1 ::= "unit";
TLight.   Type1 ::= "Light";
TList.    Type1 ::= "List" "<" Type ">";
TRef.     Type1 ::= "&" Type;
TMutRef.  Type1 ::= "&mut" Type;
TUnknown. Type1 ::= "?" ;

_. Type2 ::= "(" Type ")";
_. Type1 ::= Type2;
_. Type  ::= Type1;

-- STATEMENTS ---------------------------------------------------------
SAss.     Stmt ::= "ass" Ident "=" Exp ";" ;
SLet.     Stmt ::= "val" Ident "=" Exp ";" ;
SLetAnn.  Stmt ::= "val" Ident ":" Type "=" Exp ";" ;
SLetM.    Stmt ::= "val" "mut" Ident "=" Exp ";" ; 
SLetMAnn. Stmt ::= "val" "mut" Ident ":" Type "=" Exp ";" ;
SFun.     Stmt ::= "fun" Ident "(" [Arg] ") -> " Type " = {" [Stmt] "return " Exp "}" ;
SIf.      Stmt ::= "if" "(" Exp ")" "{" [Stmt] "}" ;
SIfElse.  Stmt ::= "if" "(" Exp ")" "{" [Stmt] "}" "else" "{" [Stmt] "}" ;
SWhile.   Stmt ::= "while" "(" Exp ")" "{" [Stmt] "}" ;


SPush.   Stmt ::= Exp8 "." "push"   "(" Exp7 ")"      ";" ;
SInsert. Stmt ::= Exp8 "." "insert" "(" Exp7 "," Exp7 ")" ";" ;
SSetIdx. Stmt ::= Exp8 [IndexList] "=" Exp7 ";" ;
-- SReturn. Stmt ::= "return " Exp8 ";" ;
SExp. Stmt ::= Exp ";" ;
SAssDeref. Stmt ::= "*" Exp8 "=" Exp8 ";" ;

-- EXPRESSIONS --------------------------------------------------------

-- Arithmetic
EInt. Exp7  ::= Integer;

EMul. Exp6  ::= Exp6 "*" Exp7;
EDiv. Exp6  ::= Exp6 "/" Exp7;
EAdd. Exp5  ::= Exp5 "+" Exp6;
ESub. Exp5  ::= Exp5 "-" Exp6;

-- Booleans
ETrue.  Exp3  ::= "True";
EFalse. Exp3  ::= "False";

ENot.   Exp3  ::= "!" Exp3;
EAnd.   Exp2  ::= Exp2 "&&" Exp3;
EOr.    Exp1  ::= Exp1 "||" Exp2;

-- Comparisons
EEq.  Exp  ::= Exp "==" Exp1;
ELt.  Exp4 ::= Exp4 "<" Exp5;
EGt.  Exp4 ::= Exp4 ">" Exp5;
ELeq. Exp4 ::= Exp4 "<=" Exp5;
EGeq. Exp4 ::= Exp4 ">=" Exp5;

-- Control flow
-- EIfElse.  Exp8 ::= "if" "(" Exp ")" "{" Exp "}" "else" "{" Exp "}" ;

-- Let bindings
ELet. Exp8 ::= "let" Ident "=" Exp "in" Exp;
EVar. Exp8 ::= Ident;

-- Functions
EApp. Exp8 ::= Ident "(" [Exp7] ")";

EVoid. Exp8 ::= "void" ;

-- Light
ERed.    Exp7 ::= "Red" ;
EYellow. Exp7 ::= "Yellow" ;
EGreen.  Exp7 ::= "Green" ;

-- Lists
EVec. Exp7 ::= "vec!" "[" [Exp7] "]" ;
EIdx. Exp7 ::= Exp7 "[" Exp7 "]" ;

-- List operations (of type unit)
ERemove. Exp8 ::= Exp8 "." "remove" "(" Exp7 ")" ;

-- References (borrows)
ERef.    Exp8 ::= "&" Exp8 ;
EMutRef. Exp8 ::= "&mut" Exp8 ;
EDeref.  Exp8 ::= "*" Exp8;

-- Concurrency
-- EPar. Exp8 ::= 

-- This part sets up the order of operation
_. Exp8 ::= "(" Exp ")" ;
_. Exp7 ::= Exp8 ;
_. Exp6 ::= Exp7 ;
_. Exp5 ::= Exp6 ;
_. Exp4 ::= Exp5 ;
_. Exp3 ::= Exp4 ;
_. Exp2 ::= Exp3 ;
_. Exp1 ::= Exp2 ;
_. Exp  ::= Exp1 ;
